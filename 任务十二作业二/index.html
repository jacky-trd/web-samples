<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8"/>
    <title>高级前端开发工程师面试题</title>
    <link rel="stylesheet" href="style.css"/>
</head>

<body>
<!-- 主体  start -->
<article>
    <!-- 页面标题 -->
    <header>
        <h1>高级前端开发工程师面试题</h1>
    </header>
    <!-- 试题列表 -->
    <ol>
        <li>
            <h3>请解释一下什么web worker？</h3>
            <ol>
                <li>
                    <p>web
                        worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了；</p>
                </li>
                <li>
                    <p>Worker对象分为两种：专用式Web Worker和共享式Web Worker：专用式的Web Worker只能被当个页面使用，而共享式的Web Worker可以在被多个页面使用；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>跨域都有哪些实现方式？以及它们的缺点；</h3>
            <ol>
                <li>
                    <p>使用proxy代理进行跨域</p>
                    <p>这种方式首先将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端，需要注意的是如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功；</p>
                    <p>缺点：有可能得不到想要的结果；</p>
                </li>
                <li>
                    <p>使用JSONP进行跨域</p>
                    <p>这种方式主要是通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。实际项目中JSONP通常用来获取json格式数据，这时前后端通常约定一个参数callback，该参数的值，就是处理返回数据的函数名称；</p>
                    <p>缺点：1.这种方式无法发送post请求；2.另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定；</p>
                </li>
                <li>
                    <p>使用CORS进行跨域</p>
                    <p>这是现代浏览器支持跨域资源请求的一种方式，当你使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin;浏览器判断该相应头中是否包含Origin的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据；</p>
                    <p>缺点：1.兼容性；2.PUT或DELETE时会有两次请求；</p>
                </li>
                <li>
                    <p>使用XDR进行跨域</p>
                    <p>这是IE8、IE9提供的一种跨域解决方案，功能较弱只支持get跟post请求，而且对于协议不同的跨域是无能为力的，比如在http协议下发送https请求；</p>
                    <p>缺点：只支持IE8、IE9；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>一个页面从输入URL到页面加载显示完成，这个过程都发生什么？</h3>
            <ol>
                <li>
                    <p>首先，在浏览器地址栏中输入url；</p>
                </li>
                <li>
                    <p>浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作；</p>
                    <ul>
                        <li><strong>浏览器缓存</strong>：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li>
                        <li><strong>操作系统缓存：</strong>如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；</li>
                        <li><strong>路由器缓存</strong>：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li>
                        <li><strong>ISP缓存：</strong>若上述均失败，继续向ISP搜索。</li>
                    </ul>
                </li>
                <li>
                    <p>在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址；</p>
                </li>
                <li>
                    <p>浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手；</p>
                </li>
                <li>
                    <p>握手成功后，浏览器向服务器发送http请求，请求数据包；</p>
                </li>
                <li>
                    <p>服务器处理收到的请求，将数据返回至浏览器；</p>
                </li>
                <li>
                    <p>浏览器收到HTTP响应；</p>
                </li>
                <li>
                    <p>读取页面内容，浏览器渲染，解析html源码；</p>
                </li>
                <li>
                    <p>生成Dom树、解析css样式、js交互；</p>
                </li>
                <li>
                    <p>客户端和服务器交互；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>http请求方式都有哪些？以及它们的优缺点；</h3>
            <ol>
                <li>
                    <p>GET：它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端；</p>
                </li>
                <li>
                    <p>POST：向URL指定的资源提交数据或附加新的数据；POST比GET更安全，因为参数不会被保存在浏览器历史或者web服务器日志中；</p>
                </li>
                <li>
                    <p>PUT：简单地说：通常用于向服务器发送请求，如果URI不存在，则要求服务器根据请求创建资源，如果存在，服务器就接受请求内容，并修改URI资源的原始版本；</p>
                </li>
                <li>
                    <p>HEAD：HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改；</p>
                </li>
                <li>
                    <p>DELETE：删除服务器上的某资源；</p>
                </li>
                <li>
                    <p>OPTIONS：它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息；</p>
                </li>
                <li>
                    <p>TRACE：回显服务器收到的请求，主要用于测试或诊断；</p>
                </li>
                <li>
                    <p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>详细说明call，apply，bind方法之间的区别；</h3>
            <ol>
                <li>
                    <p>首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象；</p>
                </li>
                <li>
                    <p>call，apply可以在函数运行时动态改变this的指向，它们之间的区别在于参数的不同，call从第二个参数开始要一个一个的传入，apply从第二个参数是一个参数数组，其内容就是需要传入的参数；</p>
                </li>
                <li>
                    <p>bind是新创建一个函数，然后把它的上下文绑定到bind()括号中的参数上，然后将它返回，所以，bind后函数不会执行，而只是返回一个改变了上下文的函数副本，而call和apply是直接执行函数；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>什么是JavaScript的闭包？以及它的优缺点；</h3>
            <ol>
                <li>
                    <p>
                        使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念；</p>
                </li>
                <li>
                    <p>闭包有三个特性：
                        1.函数嵌套函数；
                        2.函数内部可以引用外部的参数和变量；
                        3.参数和变量不会被垃圾回收机制回收；
                    </p>
                </li>
            </ol>
        </li>
        <li>
            <h3>说出全部http状态码？以及它们的意义；</h3>
            <ol>
                <li>
                    <p>1**：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束；</p>
                </li>
                <li>
                    <p>2**：表示请求成功；</p>
                </li>
                <li>
                    <p>3**：表示重定向；</p>
                </li>
                <li>
                    <p>4**：表示客户端错误；</p>
                </li>
                <li>
                    <p>5**：表示服务器端错误；</p>
                </li>
                <li>
                    <p>100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收；</p>
                </li>
                <li>
                    <p>200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回；</p>
                </li>
                <li>
                    <p>202（Accepted），服务器已接受请求，但尚未处理；</p>
                </li>
                <li>
                    <p>204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容；</p>
                </li>
                <li>
                    <p>
                        205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入；</p>
                </li>
                <li>
                    <p>206（Partial-Content），服务器已经成功处理了部分 GET 请求；</p>
                </li>
                <li>
                    <p>301（Moved-Permanently），永久性重定向；</p>
                </li>
                <li>
                    <p>302（Moved-Temporarily），暂时性重定向；</p>
                </li>
                <li>
                    <p>304（Not-Modified），浏览器端缓存的资源依然有效；</p>
                </li>
                <li>
                    <p>400（Bad-Reques），请求有误，当前请求无法被服务器理解；</p>
                </li>
                <li>
                    <p>401（Unauthorized），当前请求需要用户验证；</p>
                </li>
                <li>
                    <p>403（Forbidden），服务器已经理解请求，但是拒绝执行它；</p>
                </li>
                <li>
                    <p>404（Not-Found），请求的资源没有被找到；</p>
                </li>
                <li>
                    <p>500（Interval Server Error），服务器内部错误；</p>
                </li>
                <li>
                    <p>502（Bad GateWay），网关出错；</p>
                </li>
                <li>
                    <p>503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求；</p>
                </li>
                <li>
                    <p>504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>xss，csrf的概念以及防范方法；</h3>
            <ol>
                <li>
                    <p>XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等；</p>
                    <p>XSS防御：1.完善的过滤体系；2.Html encode；</p>
                </li>
                <li>
                    <p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF；</p>
                    <p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全；</p>
                    <p>受害者必须依次完成两个步骤：1.登录受信任网站A，并在本地生成Cookie；2.在不登出A的情况下，访问危险网站B；</p>
                    <p>服务端进行CSRF防御:1.Cookie Hashing(所有表单都包含同一个伪随机值)；2.验证码；3.One-Time Tokens(不同的表单包含一个不同的伪随机值)；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>说出你知道的雅虎军规；</h3>
            <ol>
                <li>
                    <p>尽量减少HTTP请求数；</p>
                </li>
                <li>
                    <p>减少DNS查找；</p>
                </li>
                <li>
                    <p>避免重定向；</p>
                </li>
                <li>
                    <p>让Ajax可缓存；</p>
                </li>
                <li>
                    <p>延迟加载组件；</p>
                </li>
                <li>
                    <p>预加载组件</p>
                </li>
                <li>
                    <p>减少DOM元素的数量；</p>
                </li>
                <li>
                    <p>跨域分离组件；</p>
                </li>
                <li>
                    <p>尽量少用iframe；</p>
                </li>
                <li>
                    <p>杜绝404；</p>
                </li>
                <li>
                    <p>避免使用CSS表达式；</p>
                </li>
                <li>
                    <p>选择&lt;link&gt;舍弃@import；</p>
                </li>
                <li>
                    <p>避免使用滤镜；</p>
                </li>
                <li>
                    <p>把样式表放在顶部；</p>
                </li>
                <li>
                    <p>去除重复脚本；</p>
                </li>
                <li>
                    <p>尽量减少DOM访问；</p>
                </li>
                <li>
                    <p>用智能的事件处理器；</p>
                </li>
                <li>
                    <p>把脚本放在底部；</p>
                </li>
                <li>
                    <p>把JavaScript和CSS放到外面；</p>
                </li>
                <li>
                    <p>压缩JavaScript和CSS；</p>
                </li>
                <li>
                    <p>优化图片；</p>
                </li>
                <li>
                    <p>优化CSS Sprite；</p>
                </li>
                <li>
                    <p>不要用HTML缩放图片；</p>
                </li>
                <li>
                    <p>用小的可缓存的favicon.ico（P.S. 收藏夹图标）；</p>
                </li>
                <li>
                    <p>给Cookie减肥；</p>
                </li>
                <li>
                    <p>把组件放在不含cookie的域下；</p>
                </li>
                <li>
                    <p>保证所有组件都小于25K；</p>
                </li>
                <li>
                    <p>把组件打包到一个复合文档里；</p>
                </li>
                <li>
                    <p>开启Gzip；</p>
                </li>
                <li>
                    <p>避免图片src属性为空；</p>
                </li>
                <li>
                    <p>配置ETags；</p>
                </li>
                <li>
                    <p>对Ajax用GET请求；</p>
                </li>
                <li>
                    <p>尽早清空缓冲区；</p>
                </li>
                <li>
                    <p>使用CDN（内容分发网络）；</p>
                </li>
                <li>
                    <p>添上Expires或者Cache-Control HTTP头；</p>
                </li>
            </ol>
        </li>
        <li>
            <h3>创建ajax的全过程；</h3>
            <ol>
                <li>
                    <p>创建`XMLHttpRequest`对象,也就是创建一个异步调用对象；</p>
                </li>
                <li>
                    <p>创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息；</p>
                </li>
                <li>
                    <p>设置响应`HTTP`请求状态变化的函数；</p>
                </li>
                <li>
                    <p>发送`HTTP`请求；</p>
                </li>
                <li>
                    <p>获取异步调用返回的数据；</p>
                </li>
                <li>
                    <p>使用JavaScript和DOM实现局部刷新；</p>
                </li>
            </ol>
        </li>
    </ol>
</article>
<!-- 主体  end -->
</body>

</html>
